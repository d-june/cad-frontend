(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([[185],{

/***/ 72431:
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ 37628:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __webpack_unused_export__;

"use client";

var _interopRequireDefault = __webpack_require__(26314);
__webpack_unused_export__ = ({
  value: true
});
exports.Z = void 0;
var _createSvgIcon = _interopRequireDefault(__webpack_require__(80984));
var _jsxRuntime = __webpack_require__(57437);
var _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
  d: "M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"
}), 'LocalPhone');
exports.Z = _default;

/***/ }),

/***/ 73720:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __webpack_unused_export__;

"use client";

var _interopRequireDefault = __webpack_require__(26314);
__webpack_unused_export__ = ({
  value: true
});
exports.Z = void 0;
var _createSvgIcon = _interopRequireDefault(__webpack_require__(80984));
var _jsxRuntime = __webpack_require__(57437);
var _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
  d: "m5 9 1.41 1.41L11 5.83V22h2V5.83l4.59 4.59L19 9l-7-7-7 7z"
}), 'North');
exports.Z = _default;

/***/ }),

/***/ 73289:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __webpack_unused_export__;

"use client";

var _interopRequireDefault = __webpack_require__(26314);
__webpack_unused_export__ = ({
  value: true
});
exports.Z = void 0;
var _createSvgIcon = _interopRequireDefault(__webpack_require__(80984));
var _jsxRuntime = __webpack_require__(57437);
var _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
  d: "M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"
}), 'ShoppingCart');
exports.Z = _default;

/***/ }),

/***/ 99150:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 78139, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 32083));
Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 69856));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 46685, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 80319));
Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 54267));
Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 48882));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 74229, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 62471, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 87946, 23))

/***/ }),

/***/ 32083:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   theme: function() { return /* binding */ theme; }
/* harmony export */ });
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30606);
/* __next_internal_client_entry_do_not_use__ theme auto */ 
const theme = (0,_mui_material__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)({
    palette: {
        primary: {
            main: "#18333E"
        }
    },
    components: {
        MuiButtonBase: {
            defaultProps: {
                disableRipple: true
            }
        },
        MuiTypography: {
            defaultProps: {
                fontFamily: [
                    "Montserrat"
                ]
            }
        },
        MuiPaper: {
            styleOverrides: {
                rounded: {
                    borderRadius: 8
                }
            }
        },
        MuiPopover: {},
        MuiIconButton: {
            styleOverrides: {
                root: {
                    border: "1px solid #73A36B",
                    borderRadius: "5px",
                    textTransform: "inherit",
                    fontSize: 16,
                    transition: "all 0.3s ease-in-out 0s",
                    "&:hover": {
                        border: "1px solid #FF7F5C",
                        color: "#FF7F5C",
                        background: "inherit",
                        boxShadow: "0 1px 1px rgb(0 0 0 / 15%), 0 4px 7px rgb(0 0 0 / 0%), 0 -1 0 rgb(0 0 0 / 5%), -1px 0 0 rgb(0 0 0 / 5%), 1px 0 0 rgb(0 0 0 / 5%) !important"
                    },
                    "&:active": {
                        boxShadow: "0 1px 1px rgb(0 0 0 / 15%), 0 4px 7px rgb(0 0 0 / 0%), 0 -1 0 rgb(0 0 0 / 5%), -1px 0 0 rgb(0 0 0 / 5%), 1px 0 0 rgb(0 0 0 / 5%) !important",
                        transform: "translateY(1px)"
                    }
                }
            }
        },
        MuiButton: {
            styleOverrides: {
                root: {
                    border: "1px solid #229283",
                    borderRadius: "2px",
                    textTransform: "uppercase",
                    color: "#229283",
                    transition: "all 0.3s ease-out 0s",
                    "&:hover": {
                        border: "1px solid #229283",
                        color: "#fff",
                        background: "#229283",
                        boxShadow: "none"
                    },
                    "&:active": {
                        boxShadow: "none",
                        transform: "translateY(1px)"
                    }
                },
                contained: {
                    border: "1px solid #229283",
                    background: "#229283",
                    borderRadius: "2px",
                    textTransform: "uppercase",
                    boxShadow: "none",
                    color: "#fff",
                    transition: "all 0.3s ease-out 0s",
                    "&:hover": {
                        border: "1px solid #229283",
                        background: "inherit",
                        boxShadow: "none",
                        borderRadius: "2px",
                        color: "#229283"
                    }
                }
            }
        }
    }
});


/***/ }),

/***/ 48882:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Header: function() { return /* binding */ Header; },
  navigationShort: function() { return /* binding */ navigationShort; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(57437);
// EXTERNAL MODULE: ./node_modules/next/link.js
var next_link = __webpack_require__(61396);
var link_default = /*#__PURE__*/__webpack_require__.n(next_link);
// EXTERNAL MODULE: ./src/components/Header/Header.module.scss
var Header_module = __webpack_require__(76612);
var Header_module_default = /*#__PURE__*/__webpack_require__.n(Header_module);
// EXTERNAL MODULE: ./src/components/Logo/Logo.module.scss
var Logo_module = __webpack_require__(61815);
var Logo_module_default = /*#__PURE__*/__webpack_require__.n(Logo_module);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2265);
;// CONCATENATED MODULE: ./src/components/Logo/Logo.tsx




const Logo = ()=>{
    return /*#__PURE__*/ (0,jsx_runtime.jsx)((link_default()), {
        href: "/",
        className: (Logo_module_default()).logo,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: (Logo_module_default()).logoTitle,
                children: "CAD"
            })
        })
    });
};
/* harmony default export */ var Logo_Logo = (Logo);

// EXTERNAL MODULE: ./node_modules/@mui/icons-material/LocalPhone.js
var LocalPhone = __webpack_require__(37628);
// EXTERNAL MODULE: ./src/components/Navigation/index.tsx
var Navigation = __webpack_require__(80319);
// EXTERNAL MODULE: ./src/redux/slices/cart/selectors.ts
var selectors = __webpack_require__(95439);
// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 13 modules
var es = __webpack_require__(3198);
// EXTERNAL MODULE: ./node_modules/@mui/icons-material/ShoppingCart.js
var ShoppingCart = __webpack_require__(73289);
;// CONCATENATED MODULE: ./src/components/Header/HeaderCart/index.tsx
/* __next_internal_client_entry_do_not_use__ default auto */ 






const HeaderCart = ()=>{
    const { products, totalPrice } = (0,es/* useSelector */.v9)(selectors/* selectCart */.K);
    const isMounted = (0,react.useRef)(false);
    const totalCount = products.reduce((sum, product)=>sum + product.aroma.count, 0);
    (0,react.useEffect)(()=>{
        if (isMounted.current) {
            const json = JSON.stringify(products);
            localStorage.setItem("cart", json);
        }
        isMounted.current = true;
    }, [
        products
    ]);
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)((link_default()), {
        href: "/cart",
        className: (Header_module_default()).headerCart,
        children: [
            totalPrice === 0 ? /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                className: (Header_module_default()).cartTitle,
                children: [
                    "Корзина ",
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(ShoppingCart/* default */.Z, {})
                ]
            }) : /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                className: (Header_module_default()).cartTitle,
                children: [
                    totalPrice + " ₽",
                    " ",
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(ShoppingCart/* default */.Z, {})
                ]
            }),
            totalCount > 0 && /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: (Header_module_default()).cartTotalCount,
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)("span", {
                    children: totalCount
                })
            })
        ]
    });
};
/* harmony default export */ var Header_HeaderCart = (HeaderCart);

// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/value/index.mjs
var value = __webpack_require__(74101);
// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/utils/use-constant.mjs
var use_constant = __webpack_require__(10961);
// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/utils/errors.mjs
var errors = __webpack_require__(46567);
;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/utils/resolve-element.mjs


function resolveElements(elements, scope, selectorCache) {
    var _a;
    if (typeof elements === "string") {
        let root = document;
        if (scope) {
            (0,errors/* invariant */.k)(Boolean(scope.current), "Scope provided, but no element detected.");
            root = scope.current;
        }
        if (selectorCache) {
            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));
            elements = selectorCache[elements];
        }
        else {
            elements = root.querySelectorAll(elements);
        }
    }
    else if (elements instanceof Element) {
        elements = [elements];
    }
    /**
     * Return an empty array
     */
    return Array.from(elements || []);
}



;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/resize/handle-element.mjs


const resizeHandlers = new WeakMap();
let observer;
function getElementSize(target, borderBoxSize) {
    if (borderBoxSize) {
        const { inlineSize, blockSize } = borderBoxSize[0];
        return { width: inlineSize, height: blockSize };
    }
    else if (target instanceof SVGElement && "getBBox" in target) {
        return target.getBBox();
    }
    else {
        return {
            width: target.offsetWidth,
            height: target.offsetHeight,
        };
    }
}
function notifyTarget({ target, contentRect, borderBoxSize, }) {
    var _a;
    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {
        handler({
            target,
            contentSize: contentRect,
            get size() {
                return getElementSize(target, borderBoxSize);
            },
        });
    });
}
function notifyAll(entries) {
    entries.forEach(notifyTarget);
}
function createResizeObserver() {
    if (typeof ResizeObserver === "undefined")
        return;
    observer = new ResizeObserver(notifyAll);
}
function resizeElement(target, handler) {
    if (!observer)
        createResizeObserver();
    const elements = resolveElements(target);
    elements.forEach((element) => {
        let elementHandlers = resizeHandlers.get(element);
        if (!elementHandlers) {
            elementHandlers = new Set();
            resizeHandlers.set(element, elementHandlers);
        }
        elementHandlers.add(handler);
        observer === null || observer === void 0 ? void 0 : observer.observe(element);
    });
    return () => {
        elements.forEach((element) => {
            const elementHandlers = resizeHandlers.get(element);
            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);
            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {
                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);
            }
        });
    };
}



;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/resize/handle-window.mjs
const windowCallbacks = new Set();
let windowResizeHandler;
function createWindowResizeHandler() {
    windowResizeHandler = () => {
        const size = {
            width: window.innerWidth,
            height: window.innerHeight,
        };
        const info = {
            target: window,
            size,
            contentSize: size,
        };
        windowCallbacks.forEach((callback) => callback(info));
    };
    window.addEventListener("resize", windowResizeHandler);
}
function resizeWindow(callback) {
    windowCallbacks.add(callback);
    if (!windowResizeHandler)
        createWindowResizeHandler();
    return () => {
        windowCallbacks.delete(callback);
        if (!windowCallbacks.size && windowResizeHandler) {
            windowResizeHandler = undefined;
        }
    };
}



;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/resize/index.mjs



function resize(a, b) {
    return typeof a === "function" ? resizeWindow(a) : resizeElement(a, b);
}



// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/utils/progress.mjs
var progress = __webpack_require__(42868);
// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs
var velocity_per_second = __webpack_require__(69815);
;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs



/**
 * A time in milliseconds, beyond which we consider the scroll velocity to be 0.
 */
const maxElapsed = 50;
const createAxisInfo = () => ({
    current: 0,
    offset: [],
    progress: 0,
    scrollLength: 0,
    targetOffset: 0,
    targetLength: 0,
    containerLength: 0,
    velocity: 0,
});
const createScrollInfo = () => ({
    time: 0,
    x: createAxisInfo(),
    y: createAxisInfo(),
});
const keys = {
    x: {
        length: "Width",
        position: "Left",
    },
    y: {
        length: "Height",
        position: "Top",
    },
};
function updateAxisInfo(element, axisName, info, time) {
    const axis = info[axisName];
    const { length, position } = keys[axisName];
    const prev = axis.current;
    const prevTime = info.time;
    axis.current = element["scroll" + position];
    axis.scrollLength = element["scroll" + length] - element["client" + length];
    axis.offset.length = 0;
    axis.offset[0] = 0;
    axis.offset[1] = axis.scrollLength;
    axis.progress = (0,progress/* progress */.Y)(0, axis.scrollLength, axis.current);
    const elapsed = time - prevTime;
    axis.velocity =
        elapsed > maxElapsed
            ? 0
            : (0,velocity_per_second/* velocityPerSecond */.R)(axis.current - prev, elapsed);
}
function updateScrollInfo(element, info, time) {
    updateAxisInfo(element, "x", info, time);
    updateAxisInfo(element, "y", info, time);
    info.time = time;
}



;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs
function calcInset(element, container) {
    const inset = { x: 0, y: 0 };
    let current = element;
    while (current && current !== container) {
        if (current instanceof HTMLElement) {
            inset.x += current.offsetLeft;
            inset.y += current.offsetTop;
            current = current.offsetParent;
        }
        else if (current.tagName === "svg") {
            /**
             * This isn't an ideal approach to measuring the offset of <svg /> tags.
             * It would be preferable, given they behave like HTMLElements in most ways
             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we
             * can't use .getBBox() like most SVG elements as these provide the offset
             * relative to the SVG itself, which for <svg /> is usually 0x0.
             */
            const svgBoundingBox = current.getBoundingClientRect();
            current = current.parentElement;
            const parentBoundingBox = current.getBoundingClientRect();
            inset.x += svgBoundingBox.left - parentBoundingBox.left;
            inset.y += svgBoundingBox.top - parentBoundingBox.top;
        }
        else if (current instanceof SVGGraphicsElement) {
            const { x, y } = current.getBBox();
            inset.x += x;
            inset.y += y;
            let svg = null;
            let parent = current.parentNode;
            while (!svg) {
                if (parent.tagName === "svg") {
                    svg = parent;
                }
                parent = current.parentNode;
            }
            current = svg;
        }
        else {
            break;
        }
    }
    return inset;
}



;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs
const ScrollOffset = {
    Enter: [
        [0, 1],
        [1, 1],
    ],
    Exit: [
        [0, 0],
        [1, 0],
    ],
    Any: [
        [1, 0],
        [0, 1],
    ],
    All: [
        [0, 0],
        [1, 1],
    ],
};



;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs
const namedEdges = {
    start: 0,
    center: 0.5,
    end: 1,
};
function resolveEdge(edge, length, inset = 0) {
    let delta = 0;
    /**
     * If we have this edge defined as a preset, replace the definition
     * with the numerical value.
     */
    if (namedEdges[edge] !== undefined) {
        edge = namedEdges[edge];
    }
    /**
     * Handle unit values
     */
    if (typeof edge === "string") {
        const asNumber = parseFloat(edge);
        if (edge.endsWith("px")) {
            delta = asNumber;
        }
        else if (edge.endsWith("%")) {
            edge = asNumber / 100;
        }
        else if (edge.endsWith("vw")) {
            delta = (asNumber / 100) * document.documentElement.clientWidth;
        }
        else if (edge.endsWith("vh")) {
            delta = (asNumber / 100) * document.documentElement.clientHeight;
        }
        else {
            edge = asNumber;
        }
    }
    /**
     * If the edge is defined as a number, handle as a progress value.
     */
    if (typeof edge === "number") {
        delta = length * edge;
    }
    return inset + delta;
}



;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs


const defaultOffset = [0, 0];
function resolveOffset(offset, containerLength, targetLength, targetInset) {
    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;
    let targetPoint = 0;
    let containerPoint = 0;
    if (typeof offset === "number") {
        /**
         * If we're provided offset: [0, 0.5, 1] then each number x should become
         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target
         * and container etc.
         */
        offsetDefinition = [offset, offset];
    }
    else if (typeof offset === "string") {
        offset = offset.trim();
        if (offset.includes(" ")) {
            offsetDefinition = offset.split(" ");
        }
        else {
            /**
             * If we're provided a definition like "100px" then we want to apply
             * that only to the top of the target point, leaving the container at 0.
             * Whereas a named offset like "end" should be applied to both.
             */
            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];
        }
    }
    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);
    containerPoint = resolveEdge(offsetDefinition[1], containerLength);
    return targetPoint - containerPoint;
}



// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/utils/interpolate.mjs + 3 modules
var interpolate = __webpack_require__(3245);
// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/utils/offsets/default.mjs + 1 modules
var offsets_default = __webpack_require__(34269);
;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs






const point = { x: 0, y: 0 };
function getTargetSize(target) {
    return "getBBox" in target && target.tagName !== "svg"
        ? target.getBBox()
        : { width: target.clientWidth, height: target.clientHeight };
}
function resolveOffsets(container, info, options) {
    let { offset: offsetDefinition = ScrollOffset.All } = options;
    const { target = container, axis = "y" } = options;
    const lengthLabel = axis === "y" ? "height" : "width";
    const inset = target !== container ? calcInset(target, container) : point;
    /**
     * Measure the target and container. If they're the same thing then we
     * use the container's scrollWidth/Height as the target, from there
     * all other calculations can remain the same.
     */
    const targetSize = target === container
        ? { width: container.scrollWidth, height: container.scrollHeight }
        : getTargetSize(target);
    const containerSize = {
        width: container.clientWidth,
        height: container.clientHeight,
    };
    /**
     * Reset the length of the resolved offset array rather than creating a new one.
     * TODO: More reusable data structures for targetSize/containerSize would also be good.
     */
    info[axis].offset.length = 0;
    /**
     * Populate the offset array by resolving the user's offset definition into
     * a list of pixel scroll offets.
     */
    let hasChanged = !info[axis].interpolate;
    const numOffsets = offsetDefinition.length;
    for (let i = 0; i < numOffsets; i++) {
        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);
        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {
            hasChanged = true;
        }
        info[axis].offset[i] = offset;
    }
    /**
     * If the pixel scroll offsets have changed, create a new interpolator function
     * to map scroll value into a progress.
     */
    if (hasChanged) {
        info[axis].interpolate = (0,interpolate/* interpolate */.s)(info[axis].offset, (0,offsets_default/* defaultOffset */.Y)(offsetDefinition));
        info[axis].interpolatorOffsets = [...info[axis].offset];
    }
    info[axis].progress = info[axis].interpolate(info[axis].current);
}



;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs



function measure(container, target = container, info) {
    /**
     * Find inset of target within scrollable container
     */
    info.x.targetOffset = 0;
    info.y.targetOffset = 0;
    if (target !== container) {
        let node = target;
        while (node && node !== container) {
            info.x.targetOffset += node.offsetLeft;
            info.y.targetOffset += node.offsetTop;
            node = node.offsetParent;
        }
    }
    info.x.targetLength =
        target === container ? target.scrollWidth : target.clientWidth;
    info.y.targetLength =
        target === container ? target.scrollHeight : target.clientHeight;
    info.x.containerLength = container.clientWidth;
    info.y.containerLength = container.clientHeight;
}
function createOnScrollHandler(element, onScroll, info, options = {}) {
    return {
        measure: () => measure(element, options.target, info),
        update: (time) => {
            updateScrollInfo(element, info, time);
            if (options.offset || options.target) {
                resolveOffsets(element, info, options);
            }
        },
        notify: () => onScroll(info),
    };
}



// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/frameloop/frame.mjs + 2 modules
var frameloop_frame = __webpack_require__(72363);
;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs





const scrollListeners = new WeakMap();
const resizeListeners = new WeakMap();
const onScrollHandlers = new WeakMap();
const getEventTarget = (element) => element === document.documentElement ? window : element;
function scrollInfo(onScroll, { container = document.documentElement, ...options } = {}) {
    let containerHandlers = onScrollHandlers.get(container);
    /**
     * Get the onScroll handlers for this container.
     * If one isn't found, create a new one.
     */
    if (!containerHandlers) {
        containerHandlers = new Set();
        onScrollHandlers.set(container, containerHandlers);
    }
    /**
     * Create a new onScroll handler for the provided callback.
     */
    const info = createScrollInfo();
    const containerHandler = createOnScrollHandler(container, onScroll, info, options);
    containerHandlers.add(containerHandler);
    /**
     * Check if there's a scroll event listener for this container.
     * If not, create one.
     */
    if (!scrollListeners.has(container)) {
        const measureAll = () => {
            for (const handler of containerHandlers)
                handler.measure();
        };
        const updateAll = () => {
            for (const handler of containerHandlers) {
                handler.update(frameloop_frame.frameData.timestamp);
            }
        };
        const notifyAll = () => {
            for (const handler of containerHandlers)
                handler.notify();
        };
        const listener = () => {
            frameloop_frame/* frame */.Wi.read(measureAll, false, true);
            frameloop_frame/* frame */.Wi.update(updateAll, false, true);
            frameloop_frame/* frame */.Wi.update(notifyAll, false, true);
        };
        scrollListeners.set(container, listener);
        const target = getEventTarget(container);
        window.addEventListener("resize", listener, { passive: true });
        if (container !== document.documentElement) {
            resizeListeners.set(container, resize(container, listener));
        }
        target.addEventListener("scroll", listener, { passive: true });
    }
    const listener = scrollListeners.get(container);
    frameloop_frame/* frame */.Wi.read(listener, false, true);
    return () => {
        var _a;
        (0,frameloop_frame/* cancelFrame */.Pn)(listener);
        /**
         * Check if we even have any handlers for this container.
         */
        const currentHandlers = onScrollHandlers.get(container);
        if (!currentHandlers)
            return;
        currentHandlers.delete(containerHandler);
        if (currentHandlers.size)
            return;
        /**
         * If no more handlers, remove the scroll listener too.
         */
        const scrollListener = scrollListeners.get(container);
        scrollListeners.delete(container);
        if (scrollListener) {
            getEventTarget(container).removeEventListener("scroll", scrollListener);
            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();
            window.removeEventListener("resize", scrollListener);
        }
    };
}



// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var use_isomorphic_effect = __webpack_require__(538);
;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-scroll.mjs







function refWarning(name, ref) {
    (0,errors/* warning */.K)(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
}
const createScrollMotionValues = () => ({
    scrollX: (0,value/* motionValue */.BX)(0),
    scrollY: (0,value/* motionValue */.BX)(0),
    scrollXProgress: (0,value/* motionValue */.BX)(0),
    scrollYProgress: (0,value/* motionValue */.BX)(0),
});
function useScroll({ container, target, layoutEffect = true, ...options } = {}) {
    const values = (0,use_constant/* useConstant */.h)(createScrollMotionValues);
    const useLifecycleEffect = layoutEffect
        ? use_isomorphic_effect/* useIsomorphicLayoutEffect */.L
        : react.useEffect;
    useLifecycleEffect(() => {
        refWarning("target", target);
        refWarning("container", container);
        return scrollInfo(({ x, y }) => {
            values.scrollX.set(x.current);
            values.scrollXProgress.set(x.progress);
            values.scrollY.set(y.current);
            values.scrollYProgress.set(y.progress);
        }, {
            ...options,
            container: (container === null || container === void 0 ? void 0 : container.current) || undefined,
            target: (target === null || target === void 0 ? void 0 : target.current) || undefined,
        });
    }, [container, target, JSON.stringify(options.offset)]);
    return values;
}



;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-motion-value-event.mjs


function useMotionValueEvent(value, event, callback) {
    /**
     * useInsertionEffect will create subscriptions before any other
     * effects will run. Effects run upwards through the tree so it
     * can be that binding a useLayoutEffect higher up the tree can
     * miss changes from lower down the tree.
     */
    (0,react.useInsertionEffect)(() => value.on(event, callback), [value, event, callback]);
}



// EXTERNAL MODULE: ./node_modules/framer-motion/dist/es/render/dom/motion.mjs + 171 modules
var motion = __webpack_require__(62150);
// EXTERNAL MODULE: ./src/components/BurgerMenu/BurgerMenu.module.scss
var BurgerMenu_module = __webpack_require__(36485);
var BurgerMenu_module_default = /*#__PURE__*/__webpack_require__.n(BurgerMenu_module);
;// CONCATENATED MODULE: ./src/components/BurgerMenu/index.tsx
/* __next_internal_client_entry_do_not_use__ default auto */ 





const navigationFull = [
    {
        id: "1b",
        label: "Каталог",
        href: "/catalog"
    },
    {
        id: "2b",
        label: "Вопросы и ответы",
        href: "/questions"
    },
    {
        id: "3b",
        label: "Доставка и оплата",
        href: "/delivery"
    },
    {
        id: "4b",
        label: "О нас",
        href: "/about"
    },
    {
        id: "5b",
        label: "Инструкция",
        href: "/recomendations"
    },
    {
        id: "6b",
        label: "Контакты",
        href: "/contacts"
    }
];
const BurgerMenu = ()=>{
    const [visible, setVisible] = (0,react.useState)(false);
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: (BurgerMenu_module_default()).burgerMenu,
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: visible ? (BurgerMenu_module_default()).burgerBtn + " " + (BurgerMenu_module_default()).sidebarOpen : (BurgerMenu_module_default()).burgerBtn,
                onClick: ()=>setVisible(!visible),
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)("span", {})
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                className: visible ? (BurgerMenu_module_default()).burgerNavigation + " " + (BurgerMenu_module_default()).burgerNavigationVisible : (BurgerMenu_module_default()).burgerNavigation,
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(Navigation.Navigation, {
                        navItems: navigationFull,
                        onClick: ()=>setVisible(false)
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsxs)((link_default()), {
                        href: "tel:+79119400877",
                        className: (BurgerMenu_module_default()).burgerPhone,
                        children: [
                            /*#__PURE__*/ (0,jsx_runtime.jsx)(LocalPhone/* default */.Z, {}),
                            " 8-911-940-08-77"
                        ]
                    })
                ]
            })
        ]
    });
};
/* harmony default export */ var components_BurgerMenu = (BurgerMenu);

;// CONCATENATED MODULE: ./src/components/Header/Header.tsx
/* __next_internal_client_entry_do_not_use__ navigationShort,Header auto */ 









const navigationShort = [
    {
        id: "1h",
        label: "Каталог",
        href: "/catalog"
    },
    {
        id: "2h",
        label: "О нас",
        href: "/about"
    },
    {
        id: "3h",
        label: "Инструкция",
        href: "/recomendations"
    },
    {
        id: "4h",
        label: "Контакты",
        href: "/contacts"
    }
];
const Header = ()=>{
    const [domLoaded, setDomLoaded] = (0,react.useState)(false);
    (0,react.useEffect)(()=>{
        setDomLoaded(true);
    }, []);
    const { scrollY } = useScroll();
    const [hidden, setHidden] = (0,react.useState)(false);
    const [innerWidth, setInnerWidth] = (0,react.useState)( true && window.innerWidth);
    useMotionValueEvent(scrollY, "change", (latest)=>{
        const previous = scrollY.getPrevious();
        if (latest > previous) {
            setHidden(true);
        } else {
            setHidden(false);
        }
    });
    (0,react.useEffect)(function mount() {
        function onResize() {
            if (true) {
                setInnerWidth(window.innerWidth - 190);
            }
        }
        window.addEventListener("resize", onResize);
        return function unMount() {
            window.removeEventListener("resize", onResize);
        };
    });
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: domLoaded && /*#__PURE__*/ (0,jsx_runtime.jsx)(motion/* motion */.E.header, {
            className: (Header_module_default()).header,
            variants: {
                visible: {
                    y: 0
                },
                hidden: {
                    y: "-100%"
                }
            },
            initial: "hidden",
            animate: hidden ? "hidden" : "visible",
            transition: {
                duration: 0.5,
                ease: "easeInOut"
            },
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: (Header_module_default()).headerContainer + " container",
                children: /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                    className: (Header_module_default()).headerWrapper,
                    children: [
                        /*#__PURE__*/ (0,jsx_runtime.jsx)(Logo_Logo, {}),
                        innerWidth && innerWidth > 500 ? /*#__PURE__*/ (0,jsx_runtime.jsx)(Navigation.Navigation, {
                            navItems: navigationShort
                        }) : /*#__PURE__*/ (0,jsx_runtime.jsx)(components_BurgerMenu, {}),
                        /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                            className: (Header_module_default()).headerItem,
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime.jsxs)((link_default()), {
                                    href: "tel:+79119400877",
                                    className: (Header_module_default()).headerPhone,
                                    children: [
                                        /*#__PURE__*/ (0,jsx_runtime.jsx)(LocalPhone/* default */.Z, {}),
                                        " 8-911-940-08-77"
                                    ]
                                }),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(Header_HeaderCart, {})
                            ]
                        })
                    ]
                })
            })
        })
    });
};



/***/ }),

/***/ 80319:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Navigation: function() { return /* binding */ Navigation; }
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57437);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61396);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24033);
/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_navigation__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Navigation_module_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46471);
/* harmony import */ var _Navigation_module_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Navigation_module_scss__WEBPACK_IMPORTED_MODULE_3__);
/* __next_internal_client_entry_do_not_use__ Navigation auto */ 



const Navigation = (param)=>{
    let { navItems, column, onClick } = param;
    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.usePathname)();
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("nav", {
        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", {
            className: column ? (_Navigation_module_scss__WEBPACK_IMPORTED_MODULE_3___default().navigation) + " " + (_Navigation_module_scss__WEBPACK_IMPORTED_MODULE_3___default().navigationColumn) : (_Navigation_module_scss__WEBPACK_IMPORTED_MODULE_3___default().navigation),
            children: navItems.map((item)=>{
                const isActive = pathname === item.href;
                return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", {
                    className: isActive ? (_Navigation_module_scss__WEBPACK_IMPORTED_MODULE_3___default().navigationItem) + " active" : (_Navigation_module_scss__WEBPACK_IMPORTED_MODULE_3___default().navigationItem),
                    children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {
                        href: item.href,
                        onClick: onClick,
                        children: item.label
                    })
                }, item.id);
            })
        })
    });
};



/***/ }),

/***/ 54267:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57437);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2265);
/* harmony import */ var _mui_icons_material_North__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(73720);
/* harmony import */ var _ScrollToTop_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72518);
/* harmony import */ var _ScrollToTop_module_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ScrollToTop_module_scss__WEBPACK_IMPORTED_MODULE_2__);
/* __next_internal_client_entry_do_not_use__ default auto */ 



const ScrollToTop = ()=>{
    const [scroll, setScroll] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{
        window.addEventListener("scroll", handleScroll);
        return ()=>window.removeEventListener("scroll", handleScroll);
    }, []);
    const handleScroll = ()=>{
        setScroll(window.scrollY);
    };
    const handleScrollToTop = ()=>{
        if (true) {
            window.scrollTo({
                top: 0,
                left: 0,
                behavior: "smooth"
            });
        }
    };
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
        children: typeof document !== "undefined" && scroll > document.documentElement.clientHeight && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
            onClick: handleScrollToTop,
            className: (_ScrollToTop_module_scss__WEBPACK_IMPORTED_MODULE_2___default().scrollToTop),
            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_mui_icons_material_North__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z, {})
        })
    });
};
/* harmony default export */ __webpack_exports__["default"] = (ScrollToTop);


/***/ }),

/***/ 69856:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ReduxProvider: function() { return /* binding */ ReduxProvider; }
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(57437);
// EXTERNAL MODULE: ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js + 8 modules
var redux_toolkit_esm = __webpack_require__(20064);
// EXTERNAL MODULE: ./src/redux/slices/user.ts
var user = __webpack_require__(90235);
// EXTERNAL MODULE: ./node_modules/next-redux-wrapper/es6/index.js
var es6 = __webpack_require__(45058);
// EXTERNAL MODULE: ./src/redux/slices/cart/slice.ts + 2 modules
var slice = __webpack_require__(36666);
// EXTERNAL MODULE: ./src/redux/slices/adminPanelProducts/slice.ts
var adminPanelProducts_slice = __webpack_require__(85634);
;// CONCATENATED MODULE: ./src/redux/store.ts





function makeStore() {
    return (0,redux_toolkit_esm/* configureStore */.xC)({
        reducer: {
            userReducer: user/* userReducer */.M3,
            cartSlice: slice/* default */.ZP,
            adminPanelProductsSlice: adminPanelProducts_slice/* default */.ZP
        }
    });
}
const store = makeStore();
const wrapper = (0,es6/* createWrapper */.KV)(makeStore, {
    debug: true
});

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 13 modules
var es = __webpack_require__(3198);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2265);
;// CONCATENATED MODULE: ./src/redux/provider.tsx
/* __next_internal_client_entry_do_not_use__ ReduxProvider auto */ 



function ReduxProvider(param) {
    let { children } = param;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(es/* Provider */.zt, {
        store: store,
        children: children
    });
}


/***/ }),

/***/ 85634:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UY: function() { return /* binding */ deleteProductData; },
/* harmony export */   aG: function() { return /* binding */ deleteProductAroma; },
/* harmony export */   dy: function() { return /* binding */ updateProductImages; },
/* harmony export */   hj: function() { return /* binding */ addProductAroma; },
/* harmony export */   qH: function() { return /* binding */ setProductsData; }
/* harmony export */ });
/* unused harmony export addProductsData */
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20064);
/* harmony import */ var next_redux_wrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45058);


const initialState = {
    products: []
};
const adminPanelProductsSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__/* .createSlice */ .oM)({
    name: "adminPanelProducts",
    initialState,
    reducers: {
        setProductsData (state, action) {
            state.products = action.payload;
        },
        addProductsData (state, action) {
            state.products = [
                ...state.products,
                action.payload
            ];
        },
        deleteProductData (state, action) {
            state.products = state.products.filter((product)=>{
                product.id !== action.payload.id;
            });
        },
        updateProductImages (state, action) {
            state.products.map((product)=>{
                if (product.id === action.payload.id) {
                    product.images = action.payload.images;
                }
            });
        },
        deleteProductAroma (state, action) {
            state.products.map((product)=>{
                if (product.id === action.payload.productId) {
                    var _product_aromas;
                    product.aromas = (_product_aromas = product.aromas) === null || _product_aromas === void 0 ? void 0 : _product_aromas.filter((aroma)=>aroma.id !== action.payload.id);
                }
            });
        },
        addProductAroma (state, action) {
            state.products.map((product)=>{
                if (product.aromas && product.id === action.payload.productId) {
                    product.aromas = [
                        ...product.aromas,
                        action.payload
                    ];
                }
            });
        }
    },
    extraReducers: {
        [next_redux_wrapper__WEBPACK_IMPORTED_MODULE_0__/* .HYDRATE */ .ju]: (state, action)=>{
            state = action.payload;
        }
    }
});
const { setProductsData, addProductsData, deleteProductData, updateProductImages, addProductAroma, deleteProductAroma } = adminPanelProductsSlice.actions;
/* harmony default export */ __webpack_exports__.ZP = (adminPanelProductsSlice.reducer);


/***/ }),

/***/ 95439:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: function() { return /* binding */ selectCart; }
/* harmony export */ });
/* unused harmony export selectCartProductById */
const selectCart = (state)=>state.cartSlice;
const selectCartProductById = (id)=>(state)=>state.cartSlice.products.find((obj)=>obj.id === id);


/***/ }),

/***/ 36666:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  gK: function() { return /* binding */ addProduct; },
  LL: function() { return /* binding */ clearCart; },
  ZP: function() { return /* binding */ slice; },
  R0: function() { return /* binding */ minusProduct; },
  BG: function() { return /* binding */ plusProduct; },
  kh: function() { return /* binding */ removeProduct; }
});

// EXTERNAL MODULE: ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js + 8 modules
var redux_toolkit_esm = __webpack_require__(20064);
;// CONCATENATED MODULE: ./src/utils/calcTotalPrice.ts
const calcTotalPrice = (products)=>{
    return products.reduce((sum, obj)=>obj.price * obj.aroma.count + sum, 0);
};

;// CONCATENATED MODULE: ./src/utils/getCartFromLocalStorage.ts

const getCartFromLocalStorage = ()=>{
    let data = "";
    if (typeof localStorage !== "undefined") {
        data = localStorage.getItem("cart");
    }
    const products = data ? JSON.parse(data) : [];
    const totalPrice = calcTotalPrice(products);
    return {
        products,
        totalPrice
    };
};

;// CONCATENATED MODULE: ./src/redux/slices/cart/slice.ts



const { products, totalPrice } = getCartFromLocalStorage();
const initialState = {
    totalPrice,
    products
};
const cartSlice = (0,redux_toolkit_esm/* createSlice */.oM)({
    name: "cart",
    initialState,
    reducers: {
        addProduct (state, action) {
            state.products.push({
                ...action.payload
            });
            state.totalPrice = calcTotalPrice(state.products);
        },
        plusProduct (state, action) {
            const findProduct = state.products.find((obj)=>obj.id === action.payload.id && obj.aroma.name === action.payload.aroma);
            if (findProduct) {
                findProduct.aroma.count++;
                state.totalPrice = calcTotalPrice(state.products);
            }
        },
        minusProduct (state, action) {
            const findProduct = state.products.find((obj)=>obj.id === action.payload.id && obj.aroma.name === action.payload.aroma);
            if (findProduct) {
                findProduct.aroma.count--;
                state.totalPrice = calcTotalPrice(state.products);
            }
        },
        removeProduct (state, action) {
            state.products = state.products.filter((obj)=>obj.id !== action.payload.id || obj.aroma.name !== action.payload.aroma);
            state.totalPrice = calcTotalPrice(state.products);
        },
        clearCart (state) {
            state.products = [];
            state.totalPrice = 0;
        }
    }
});
const { addProduct, removeProduct, minusProduct, plusProduct, clearCart } = cartSlice.actions;
/* harmony default export */ var slice = (cartSlice.reducer);


/***/ }),

/***/ 90235:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: function() { return /* binding */ setUserData; },
/* harmony export */   M3: function() { return /* binding */ userReducer; }
/* harmony export */ });
/* unused harmony exports userSlice, selectUserData */
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20064);

const initialState = {
    user: null
};
const userSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__/* .createSlice */ .oM)({
    name: "user",
    initialState,
    reducers: {
        setUserData: (state, action)=>{
            console.log(action.payload);
            state.user = action.payload;
        }
    },
    extraReducers: (builder)=>{
    // [HYDRATE]: (state, action) => {
    //   state.user = action.payload.user.data;
    // },
    }
});
const { setUserData } = userSlice.actions;
const selectUserData = (state)=>state.userReducer;
const userReducer = userSlice.reducer;


/***/ }),

/***/ 62471:
/***/ (function() {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 36485:
/***/ (function(module) {

// extracted by mini-css-extract-plugin
module.exports = {"burgerMenu":"BurgerMenu_burgerMenu__2OQyT","burgerNavigation":"BurgerMenu_burgerNavigation__3gmnm","burgerPhone":"BurgerMenu_burgerPhone__GAzf_","burgerNavigationVisible":"BurgerMenu_burgerNavigationVisible__J3_V5","burgerBtn":"BurgerMenu_burgerBtn__dMC5p","sidebarOpen":"BurgerMenu_sidebarOpen__QtdLE"};

/***/ }),

/***/ 87946:
/***/ (function(module) {

// extracted by mini-css-extract-plugin
module.exports = {"footer":"Footer_footer__OYoYH","footerLogo":"Footer_footerLogo__mHj_P","footerContent":"Footer_footerContent__QQ0Yh","footerNavigation":"Footer_footerNavigation__71j2d"};

/***/ }),

/***/ 76612:
/***/ (function(module) {

// extracted by mini-css-extract-plugin
module.exports = {"header":"Header_header__MwWvM","headerContainer":"Header_headerContainer__CJXWu","headerWrapper":"Header_headerWrapper__mORfK","headerPhone":"Header_headerPhone__rbCVp","headerCart":"Header_headerCart__L4jxM","cartTitle":"Header_cartTitle__BdkoL","headerItem":"Header_headerItem__KSeaV","cartTotalCount":"Header_cartTotalCount__ZD5j7"};

/***/ }),

/***/ 61815:
/***/ (function(module) {

// extracted by mini-css-extract-plugin
module.exports = {"logo":"Logo_logo__5xyYV"};

/***/ }),

/***/ 46471:
/***/ (function(module) {

// extracted by mini-css-extract-plugin
module.exports = {"navigation":"Navigation_navigation__oP3Tz","navigationItem":"Navigation_navigationItem__lswKs","active":"Navigation_active__kQT4n","navigationColumn":"Navigation_navigationColumn__qnX5h"};

/***/ }),

/***/ 72518:
/***/ (function(module) {

// extracted by mini-css-extract-plugin
module.exports = {"scrollToTop":"ScrollToTop_scrollToTop__7NKxR"};

/***/ }),

/***/ 74229:
/***/ (function(module) {

// extracted by mini-css-extract-plugin
module.exports = {"style":{"fontFamily":"'__Montserrat_cce811', '__Montserrat_Fallback_cce811'","fontStyle":"normal"},"className":"__className_cce811"};

/***/ }),

/***/ 24033:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(68165)


/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, [42,271,685,172,198,572,64,139,897,58,971,596,744], function() { return __webpack_exec__(99150); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);